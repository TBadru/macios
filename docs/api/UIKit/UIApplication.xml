<Documentation>
  <Docs DocId="T:UIKit.UIApplication">
    <summary>Encapsulates the main processing loop for a MonoTouch application.</summary>
    <remarks>
      <para> 
	The <see cref="UIKit.UIApplication" />
	encapsulates the central administrative properties of an
	application running on iOS. Application developers must not
	instantiate new <see cref="UIKit.UIApplication" />s using constructors, but instead must use the static <see cref="UIKit.UIApplication.SharedApplication" />
        singleton property. Application developers may subclass <see cref="UIKit.UIApplication" /> and use the <c>principalClassName</c> argument to the <see cref="UIKit.UIApplication.Main(string[],string,string)" /> method to specify their subclass. In that situation, developers must create a public constructor for their subclass that the runtime will call appropriately. Subsequently, the <see cref="UIKit.UIApplication.SharedApplication" /> singleton will refer to the instance of their subclass.</para>
      <para> 
	Unlike with most classes in the <see cref="UIKit" /> namespace, events relating to the
        <see cref="UIKit.UIApplication" /> cannot be
        handled using C#-style events but rather only by the
        Objective-C style <see cref="UIKit.UIApplicationDelegate" /> delegate
        style.  </para>
      <para> 
	The <see cref="UIKit.UIApplication" /> object
        is responsible for maintaining the highest-level context of
        the application, such as the <see cref="UIKit.UIApplication.ApplicationState" />,
        the set of open windows (<see cref="UIKit.UIApplication.Windows" />), and
        functions relating to notifications (see also <see cref="UIKit.UIAppearance.Notifications.xml" />). Additionally, the <see cref="UIKit.UIApplication.UIApplication" /> method may
        be used to launch another application.  </para>
      <para> 
	The <see cref="UIKit.UIApplication" /> class
        contains methods relating to background processing, such as
        <see cref="UIKit.UIApplication.EnsureUIThread" />,
        <see cref="UIKit.UIApplication.BeginBackgroundTask(System.String,System.Action)" />,
        and <see cref="UIKit.UIApplication.EndBackgroundTask(System.IntPtr)" />.
        </para>
      <format type="text/html">
        <h2>Background Fetch</h2>
      </format>
      <para> 
	Starting with iOS 7, applications can request that they be
	woken up to download data from the server in the background.
	When this feature is enabled, the operating system will resume
	the application or launch the application at some point to
	allow the application to download any new contents it needs
	from the server.

      </para>
      <para>
	To use this, applications need to have the "fetch" background
	operation requested on their requested Entitlements as well as
	calling the <see cref="UIKit.UIApplication.SetMinimumBackgroundFetchInterval(System.Double)" />
	method with the desired wake up interval at launch.   

      </para>
      <para>
	When the operating system determines that the application
	should be resumed to download data, the <see cref="UIKit.UIApplicationDelegate.PerformFetch(UIKit.UIApplication,System.Action{UIKit.UIBackgroundFetchResult})" />
	method will be invoked.  This method should perform any
	downloads and then notify the operating system of the result
	of the operation.

      </para>
      <para>
	Applications do not really have control of when the
	application will be launched.  The actual launch time is
	determined by a set of heuristics based that the operating
	system tracks based on how the user uses the application, as
	well as tracking the status of previous download operations
	that the application has done.

      </para>
      <format type="text/html">
        <h2>Remote Notifications</h2>
      </format>
      <para> 
	Starting with iOS 7, applications can request that they be
	woken up when a remote notification is received.  When this
	feature is enabled, the operating system will resume the
	application and invoke the <see cref="UIKit.UIApplicationDelegate_Extensions.DidReceiveRemoteNotification(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary,System.Action{UIKit.UIBackgroundFetchResult})" />
	overload that takes a completion handler parameter and let it
	run.

      </para>
      <para>
	To use this, applications need to have the "remote-notification" background
	operation requested on their requested Entitlements as.

      </para>
    </remarks>
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html">Apple documentation for <c>UIApplication</c></related>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.LaunchOptionsNewsstandDownloadsKey">
    <summary>Launch Options Key: This key indicates that Newsstand has completed downloading the requested data. </summary>
    <value>Represents the value associated with the constant UIApplicationLaunchOptionsNewsstandDownloadsKey
        </value>
    <remarks>
      <para>
          The value in the dictionary for this key, contains an array of strings that represent <see cref="NewsstandKit.NKAssetDownload" /> objects.</para>
      <para>This key is used with the <see cref="Foundation.NSDictionary" /> passed to <see cref="UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)" /></para>
    </remarks>
  </Docs>
  <Docs DocId="M:UIKit.UIApplication.Main(System.String[],System.String,System.String)">
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClassName">The name of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClassName">The name of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClassName" /> is typically only specified if the application developer subclasses <see cref="UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public class Application
{
	static void Main(string[] args)
	{
		UIApplication.Main(args, "MyApp", "MyAppDelegate");
	}
}

[Register("MyApp")]
public class MyApp : UIApplication
{
//...etc...
}          

[Register("MyAppDelegate")]
public  class AppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
  <Docs DocId="M:UIKit.UIApplication.Main(System.String[],System.Type,System.Type)">
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClass">The type of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClass">The type of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClass" /> is typically only specified if the application developer subclasses <see cref="UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public class Application
{
  static void Main(string[] args)
  {
    UIApplication.Main(args, typeof (MyApp), typeof (MyAppDelegate));
  }
}

public class MyApp : UIApplication
{
//...etc...
}          

public class MyAppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
</Documentation>