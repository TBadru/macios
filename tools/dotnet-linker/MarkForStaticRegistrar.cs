// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System.Linq;

using Mono.Cecil;

using Registrar;
using Xamarin.Bundler;
using Xamarin.Linker;

#nullable enable

namespace Mono.Linker.Steps {

	// This class marks APIs referenced by the native code generated by the static registrar.
	public class MarkForStaticRegistrar : ConfigurationAwareSubStep {
		protected override string Name { get => "Mark For Static Registrar"; }

		protected override int ErrorCode { get => 2460; }

		public override SubStepTargets Targets => SubStepTargets.Method;

		public override bool IsActiveFor (AssemblyDefinition assembly)
		{
			if (Configuration.Application.Optimizations.OptimizeBlockLiteralSetupBlock != true)
				return false;

			if (Configuration.Application.Registrar != RegistrarMode.Static)
				return false;

			return Annotations.GetAction (assembly) == AssemblyAction.Link;
		}

		protected override void Process (MethodDefinition method)
		{
			ProcessDelegateProxyAttribute (method);
		}

		// Mark the Invoke method in the type pointed to by the DelegateProxy attribute,
		// because it may only be referenced from native code when using the static registrar.
		void ProcessDelegateProxyAttribute (MethodDefinition method)
		{
			if (!StaticRegistrar.IsDelegate (method.ReturnType.Resolve ()))
				return;

			var getDelegateProxyType = LinkContext.StaticRegistrar.GetDelegateProxyType (method);
			if (getDelegateProxyType is null)
				return;

			var invokeMethod = getDelegateProxyType.Methods.SingleOrDefault (m => m.Name == "Invoke");
			if (invokeMethod is null)
				return;

			Annotations.AddPreservedMethod (getDelegateProxyType, invokeMethod);
		}
	}
}
